# Парное программирование

---

## Введение

В рамках четвёртой лабораторной работы мы изучили различные стили парного программирования и применили их на практике при разработке нового функционала для нашего проекта QuizNest. Целью было не только выполнить конкретные задачи, но и оценить влияние парной работы на качество кода, скорость разработки и командное взаимодействие.

Мы опробовали два стиля, рекомендованных в задании:
- **Ведущий-ведомый**;
- **Пинг-понг**.

В качестве задач были выбраны  подзадачи из эпика E3 (AI-генерация контента) и E4 (геймификация), которые требовали как глубокого понимания логики, так и аккуратной реализации интеграции с AI-сервисами.

---

## 1. Какую задачу реализовывали?

Мы работали над двумя связанными задачами из бэклога второго спринта:

### Задача А: «Реализация адаптивной сложности вопросов» (US3.2)
**Описание:** Необходимо было добавить механизм, который на основе истории ответов пользователя определяет его уровень знаний и при генерации новых вопросов через AI передаёт параметр сложности (easy/medium/hard). Требовалось:
- Проанализировать существующие данные о попытках пользователя (количество правильных ответов, среднее время, категории);
- Написать алгоритм расчёта уровня (новичок, средний, продвинутый);
- Модифицировать запрос к AI, добавив поле `difficulty`;
- Протестировать на разных сценариях.

### Задача Б: «Реализация системы достижений (бейджей)» (US4.1)
**Описание:** Требовалось создать функционал награждения пользователей бейджами за выполнение определённых действий в приложении. Конкретные подзадачи:
- Спроектировать модель данных для достижений (название, иконка, условие получения, критерии прогресса);
- Реализовать механизм отслеживания событий (прохождение теста, получение 100% правильных ответов, быстрое прохождение и т.д.) и проверки выполнения условий;
- Разработать интерфейс отображения полученных и недоступных бейджей в профиле пользователя;
- Добавить всплывающие уведомления при получении нового достижения;
- Предусмотреть возможность добавления новых бейджей через админ-панель (CRUD).

Обе задачи имели среднюю сложность (5–8 story points) и требовали как бэкенд-логики, так и небольших изменений на фронтенде.

---

## 2. Какой стиль показался более приемлемым? Почему?

### Стиль «Ведущий-ведомый»
Этот стиль мы применили к задаче А. Один из нас выступал в роли ведущего, другой — в роли ведомого. Ведущий направлял процесс, предлагал структуру алгоритма и объяснял, какие данные нужно собирать. Ведомый писал код, задавал уточняющие вопросы и сразу же проверял написанное.

**Почему стиль оказался приемлемым:**
- Задача требовала аналитического подхода, и ведущий помог избежать типичных ошибок в расчётах.
- Ведомый получил практический опыт работы с агрегацией данных в MongoDB и научился новым приёмам отладки.
- Мы быстро пришли к рабочему решению, при этом код получился чистым и хорошо документированным.

### Стиль «Пинг-понг»
1. **Итерация 1:** Первый разработчик пишет тест для создания модели и проверки сохранения в БД → второй реализует модель и базовый CRUD через админку.
2. **Итерация 2:** Второй пишет тест для события «прохождение теста»: при завершении теста проверяется, нужно ли выдать бейдж → первый реализует обработчик события и логику проверки условия.
3. **Итерация 3:** Первый пишет тест для отображения бейджей в профиле: проверка, что полученные бейджи отображаются, а недоступные — заблокированы → Второй создаёт компонент для отображения достижений и подключает его к API.
4. **Итерация 4:** Второй пишет тест для всплывающего уведомления при получении бейджа → Первый реализует уведомления через toast-компонент.

**Почему этот стиль тоже оказался эффективным:**
- Мы с самого начала думали о тестируемости кода, что в итоге дало высокое покрытие.
- Постоянная смена ролей не давала заскучать, каждый был вовлечён и в тесты, и в реализацию.
- Мы сразу отлавливали краевые случаи (например, что делать, если контекст слишком большой, или если API Gemini временно недоступен).

### Сравнение
Оба стиля показали себя хорошо, но для разных типов задач:
- **Ведущий-ведомый** лучше подходит для сложных алгоритмических или исследовательских задач, где важен опыт одного из участников.
- **Пинг-понг** идеален для функций, которые можно чётко специфицировать и покрыть тестами; он дисциплинирует и повышает качество кода.

В нашей практике оба стиля оказались приемлемыми, и в будущем мы планируем использовать их в зависимости от контекста.

---

## 3. Что получилось? Положительные впечатления

### Положительные моменты при работе над задачей А (ведущий-ведомый)
- **Быстрое решение**: Мы потратили меньше времени вместо предполагаемого ожидаемого, так как ведущий сразу указал на оптимальный способ агрегации данных.
- **Обмен знаниями**: Один разработчик поделился знаниями, как использовать агрегационный pipeline MongoDB для сбора статистики по пользователю, а другой вспомнил некоторые тонкости работы с AI API.
- **Меньше ошибок**: Ведущий заметил потенциальную проблему с округлением уровня сложности ещё до того, как она попала в код.

### Положительные моменты при работе над задачей Б (пинг-понг)
- **Качество и тестирование:** Благодаря подходу «пинг-понг» мы с самого начала покрыли тестами ключевую логику начисления бейджей. Ни одно событие не осталось без проверки, и мы сразу отловили несколько граничных случаев (например, когда пользователь получает два бейджа одновременно).
- **Чёткое разделение:** Каждая итерация была небольшой и понятной, что позволяло быстро переключаться между ролями и не терять фокус.
- **Коллективное владение:** Оба разработчика теперь отлично понимают всю систему достижений — от моделей до UI, и в будущем смогут легко её расширять.
- **Удовлетворение от результата:** Когда мы впервые увидели, как после прохождения теста всплывает уведомление о получении бейджа «Новичок», это вызвало настоящую радость — сразу почувствовали, как геймификация оживляет приложение.

---

## 4. Что не получилось? Как можно это поправить?

### Неудачи при работе над задачей А (ведущий-ведомый)
- **Проблема**: В какой-то момент ведущий слишком увлёкся объяснениями и начал сам печатать код, не передавая клавиатуру ведомому, из-за чего ведомый начал чувствовать себя пассивным наблюдателем.
  - **Как исправить**: Нужно строго соблюдать правило «клавиатура всегда у того, кто пишет код». Если ведущий хочет показать что-то, он может попросить напарника набрать это под диктовку. Мы договорились в будущем использовать таймер (например, 15 минут) для смены ролей, даже в стиле ведущий-ведомый.

### Неудачи при работе над задачей Б (пинг-понг)
- **Проблема с иконками:** На этапе вёрстки мы не учли, что иконки бейджей должны быть в разных форматах (SVG, PNG) и подгружаться динамически. В результате в админке пришлось добавлять поле для ссылки на иконку, а не загружать файлы напрямую.
  - **Как исправить:** В следующий раз перед началом разработки нужно согласовать формат хранения медиафайлов и предусмотреть возможность загрузки через админку. Мы оперативно добавили поддержку внешних ссылок на иконки, но это заняло дополнительное время.
- **Сложность условий:** Некоторые условия для бейджей (например, «Спринтер» — быстрое прохождение) потребовали доступа к данным о времени ответа, которые не сразу были доступны в обработчике события. Пришлось модифицировать событие прохождения теста, добавив туда метрики.
  - **Как исправить:** Лучше заранее продумать, какие данные могут понадобиться для будущих достижений, и передавать их в событии. Мы сделали событие более расширяемым, теперь оно содержит всю информацию о попытке.
- **Временные затраты на тесты:** Иногда написание теста занимало больше времени, чем сама реализация, особенно на первых итерациях. Но это окупилось, когда позже при рефакторинге тесты сразу показали, что ничего не сломалось.
  - **Как исправить:** Со временем скорость написания тестов растёт. Мы решили, что для критичных по безопасности или бизнес-логике модулей такой подход оправдан.

---

## 5. Будете ли использовать ПП для других задач? Каких?

Да, мы определённо планируем использовать парное программирование в дальнейшей работе над QuizNest. Вот список задач, где ПП будет особенно полезно:

- **Разработка новых сложных функций** (например, реализация турнирной системы с рейтингами или интеграция с новым AI-сервисом). Здесь поможет стиль «ведущий-ведомый», если в паре есть более опытный разработчик.
- **Рефакторинг легаси-кода** (у нас есть первые модули, написанные в спешке). Пинг-понг позволит безопасно покрыть их тестами и улучшить структуру.
- **Сложные баги**, которые не удаётся воспроизвести или понять — совместный анализ и «резиновый утёнок» в лице напарника часто помогают найти причину.
- **Обучение новых членов команды** — введение в проект через ПП самый эффективный способ, как мы убедились сами.
- **Написание критически важных компонентов** (например, платёжный модуль или обработка персональных данных). Парное программирование снижает риск уязвимостей.

Кроме того, мы решили попробовать регулярные «парные сессии» раз в неделю для решения самых сложных задач, чтобы поддерживать высокое качество кода и обмениваться знаниями.

---

## Заключение

Лабораторная работа позволила нам на собственном опыте оценить преимущества и подводные камни парного программирования. Мы подтвердили выводы исследований: работа в паре может занимать немного больше времени (у нас вышло немного дольше, чем если бы каждый делал свою часть по отдельности), но итоговое качество кода и удовлетворённость от процесса значительно выше. Оба опробованных стиля показали свою эффективность, и мы намерены интегрировать ПП в нашу повседневную практику разработки.
