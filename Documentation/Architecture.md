# Исследование архитектурного решения

## 1 Проектирование архитектуры
### 1.1 Определить тип приложения
QuizNest — это клиент-серверное веб-приложение.
- Тип: интерактивная образовательная платформа с элементами геймификации, адаптивного обучения и реального времени.
- Подтип: AI-ассистированная система генерации контента и multiplayer-соревнований.
### 1.2 Выбрать стратегию развёртывания
Стратегия: облачное развёртывание с разделением frontend и backend, использованием Redis для кэширования сессий и Socket.IO для real-time.
Компоненты:
- **Frontend:** статическая сборка (Vite) — развёртывание на CDN/Render Static Sites
- **Backend:** Node.js/Express — контейнеризованное развёртывание (Render Web Services)
- **База данных:** MongoDB Atlas (облачная)
- **Кэш и сессии:** Redis Cloud (upstash/Redis Labs)
- **Real-time:** Socket.IO
  
### 1.3 Обосновать выбор технологии
| Компонент           | Технология                         | Обоснование                                                                                                                              |
| :------------------ | :--------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------- |
| **Frontend**        | React + Vite + PWA                | Высокая производительность, компонентный подход, возможность работы офлайн.                                                              |
| **State Management**| React Context + Hooks             | Достаточно для текущей сложности, без оверкиллинга Redux.                                                                                |
| **UI-анимации**     | Framer Motion (упрощённо)         | Плавные интерфейсы, адаптация под 60fps.                                                                                                 |
| **Backend**         | Node.js + Express                | Высокая скорость разработки, единый стек (JavaScript), большое комьюнити.                                                                |
| **База данных**     | MongoDB + Mongoose               | Гибкая схема, быстрая итерация, JSON-подобные документы.                                                                                 |                                                              |
| **Real-time**       | Socket.IO                        | Надёжная работа с WebSocket и fallback, поддержка комнат и чата.                                                                         |
| **Кэширование**     | Redis Cloud                      | Высокая скорость, управление сессиями в production, масштабируемость.                                                                    |
| **Аутентификация**  | JWT + Google OAuth               | Безопасность, бесшовный вход, ролевая модель.                                                                                           |
| **Логирование**     | Winston + env-адаптер            | Гибкость: файлы в dev, консоль в prod (Render-ready).                                                                                    |
### 1.4 Указать показатели качества
-Функциональные:
Время ответа в real-time баттлах < 200 мс
-Нефункциональные:
Производительность: оптимизированные CSS-анимации
Доступность: 99.9% uptime
Безопасность: JWT, ролевая модель, защита от XSS
Поддерживаемость: модульная архитектура, разделение на слои

### 1.5 Обозначить пути реализации сквозной функциональности
| Функция                  | Реализация                                                                                                  |
| :----------------------- | :---------------------------------------------------------------------------------------------------------- |
| **Аутентификация**       | JWT-токен в заголовке.                                                                                      |
| **Логирование действий** | Winston: middleware для HTTP-запросов, ошибок.                                                              |
| **Кэширование**          | Redis: сессии пользователей, результаты популярных тестов.                                                  |
| **Управление ошибками**  | Централизованный error-handler в Express + fallback UI на фронте.                                           |
| **Геймификация (бейджи)**| Триггеры в бизнес-логике (завершение теста, скорость, серия побед).                                         |
| **PWA-функции**          | Service Worker кэширует статику и API-ответы, фоновая синхронизация.                                        |
### 1.6 Структурная схема приложения (UML-стиль / функциональные блоки)

## 2 Анализ архитектуры

### 2.1 Диаграмма классов (регистрация и прохождение/создание тестов)
![Class](https://github.com/user-attachments/assets/b9d249ba-4197-4ded-b43b-a6127aa78e47)


## 3 Сравнение
### 3.1 Сравнение архитектур «As Is» и «To Be»
| Критерий                   | To Be (проектная)                                     | As Is (реальная)                                   | Отличие      |
| :------------------------- | :---------------------------------------------------- | :------------------------------------------------- | :----------- |
| **Адаптивность**           | Dashboard с аналитикой                                | Только уровень пользователя                        | Отсутствует   |
| **Производительность UI**  | 60fps, аппаратное ускорение                           | Оптимизировано, но не везде                        | Есть lag на сложных экранах |
| **Модульность**            | Чёткие слои (UI → Logic → Service → Data)             | Функциональная декомпозиция, но есть смешение      | Требует рефакторинга |
| **Мониторинг**             | Централизованный сбор ошибок (Sentry/Prometheus)      | Только Render-логи                                 | Отсутствует |

### 3.2 Анализ причин отличий
Приоритеты разработки
- Основное время ушло на функциональность (UI).
- Инфраструктурные задачи (кэш, мониторинг) отложены.
Эволюционный рост
- Добавление Dashboard и Leaderbord.
Технический долг
- Централизорованный сбор ошибок.
Недостаток времени на рефакторинг
- После внедрения новых фич не проводилась оптимизация существующих.

### 3.3 Пути улучшения архитектуры (рефакторинг)
-  Централизованное логирование
-  Выделение слоя аналитики
-  Оптимизация производительности UI





